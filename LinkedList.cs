/*
Связный список. АТД LinkedList
Исходно у нас имелись такие методы:

addInTail(Node item) -- добавление узла в хвост списка;
insertAfter(Node nodeAfter, Node nodeToInsert) -- вставка узла после заданного 
с дополнительным условием добавления элемента первым;
Node find(T value) -- поиск узла по значению;
findAll(T value) -- поиск всех узлов по значению;
remove(T value) -- удаление первого узла со значением Т;
removeAll(T value) -- удаление всех узлов со значением Т;
clear() -- очистка всего списка;
count() -- количество элементов в списке.
Недостатков у данного интерфейса немало. Например, команды поиска и удаления работают только с первым попавшимся узлом; одним методам передаются значения, а другим узлы, которые не очень понятно, откуда брать; реализации этих методов, судя по всему, везде потребуют циклов сканирования списка (сложность O(N)). А если в списке миллиарды элементов?

Но у данного подхода есть и более серьёзный, общий недостаток. В общем случае, переходя на уровень АТД, мы и должны думать только соответствующими абстракциями. А таких абстракций на уровне АТД всего две: это сам связный список, и хранимые в нём значения. Опускаясь же на уровень текущей реализации в виде данного шаблона, мы предлагаем совсем другой, более слабый уровень абстракции -- узлы списка и связи между ними. Кроме того, желательно, как уже отмечалось, чтобы АТД предлагал по возможности минималистичный набор операций, для работы которых не требовалось бы выполнять какие-то предварительные действия (например, создание или поиск узлов).

Сильное решение, применимое практически ко всем структурам данных, хотя бы немного идеологически отличающимся от классических массивов -- это понятие курсора.

Есть курсор, указывающий на некоторый узел в списке (курсор всегда указывает на некоторый узел, если список непустой), и есть набор операций, которые применяются к такому узлу, называемому "текущий узел".

С точки зрения пользователя АТД речь идёт не об узлах, а о значениях в списке, среди которых имеется текущее значение.

В таком случае можно обойтись набором из восьми атомарных (не сводимых друг к другу) операций:

-- head -- установить курсор на первый узел в списке;
-- tail -- установить курсор на последний узел в списке;
-- right -- сдвинуть курсор на один узел вправо;
-- get -- получить значение текущего узла;
-- put_right(значение) -- вставить следом за текущим узлом 
                      новый узел с заданным значением;
-- put_left(значение) -- вставить перед текущим узлом 
                      новый узел с заданным значением;
-- remove -- удалить текущий узел 
             (курсор смещается к правому соседу, если он есть, 
              в противном случае курсор смещается к левому соседу, 
              если он есть);
-- clear -- очистить список;
-- size -- посчитать количество узлов в списке.
Кроме того, из соображений эффективности и удобства пользователей желательно добавить такие операции (хотя они и сводимы к другим элементарным операциям):

-- add_tail(значение) -- добавить новый узел в хвост списка;
-- replace(значение) -- заменить значение текущего узла на заданное;
-- find(значение) -- установить курсор на следующий узел 
                  с искомым значением (по отношению к текущему узлу);
-- remove_all(значение) -- удалить в списке все узлы с заданным значением;
-- is_head -- находится ли курсор в начале списка?
-- is_tail -- находится ли курсор в конце списка?
-- is_value -- установлен ли курсор на какой-либо узел в списке 
              (по сути, непустой ли список).
              
                            
2.1. Опишите АТД LinkedList с предложенным набором операций.
Разделите операции на запросы и команды.
Добавьте где необходимо предусловия и постусловия.
Добавьте запросы статуса команд, для работы которых требуются предусловия (учитывайте в частности случаи, когда список пустой).              
  
abstract class LinkedList<T>

    // интерфейс класса, реализующий АТД LinkedList
    public const int HEAD_NIL = 0; // head() ещё не вызывалась
    public const int HEAD_OK = 1; // последняя head() отработала нормально
    public const int HEAD_ERR = 2; // связанный список пустой
    
    public const int TAIL_NIL = 0; // tail() ещё не вызывалась
    public const int TAIL_OK = 1; // последняя tail() отработала нормально
    public const int TAIL_ERR = 2; // связанный список пустой
        
    public const int RIGHT_NIL = 0; // right() ещё не вызывалась
    public const int RIGHT_OK = 1; // последняя right() отработала нормально
    public const int RIGHT_ERR = 2; // связанный список пустой
    
    public const int PUT_RIGHT_NIL = 0; // put_right() ещё не вызывалась
    public const int PUT_RIGHT_OK = 1; // последняя put_right() отработала нормально
    public const int PUT_RIGHT_ERR = 2; // связанный список пустой
    
    public const int PUT_LEFT_NIL = 0; // put_left() ещё не вызывалась
    public const int PUT_LEFT_OK = 1; // последняя put_left() отработала нормально
    public const int PUT_LEFT_ERR = 2; // связанный список пустой
    
    public const int REMOVE_NIL = 0; // remove() ещё не вызывалась
    public const int REMOVE_OK = 1; // последняя remove() отработала нормально
    public const int REMOVE_ERR = 2; // связанный список пустой
    
    public const int REPLACE_NIL = 0; // replace() ещё не вызывалась
    public const int REPLACE_OK = 1; // последняя replace() отработала нормально
    public const int REPLACE_ERR = 2; // связанный список пустой
    
    public const int FIND_NIL = 0; // find() ещё не вызывалась
    public const int FIND_OK = 1; // последняя find() отработала нормально
    public const int FIND_ERR = 2; // связанный список пустой
    
    public const int REMOVE_ALL_NIL = 0; // remove_all() ещё не вызывалась
    public const int REMOVE_ALL_OK = 1; // последняя remove_all() отработала нормально
    public const int REMOVE_ALL_ERR = 2; // связанный список пустой
    
    public const int GET_NIL = 0; // get() ещё не вызывалась
    public const int GET_OK = 1; // последняя get() отработала нормально
    public const int GET_ERR = 2; // связанный список пустой
    
    // конструктор
    // постусловие: создан новый пустой связанный список
    public LinkedList<T> LinkedList();
    
    // команды:
    // предусловие: связанный список не пустой
    // постусловие: курсор переметился на первый узел связанного списка
    public void head();
    
    // предусловие: связанный список не пустой
    // постусловие: курсор переметился на последний узел связанного списка
    public void tail();
    
    // предусловие: связанный список не пустой
    // постусловие: курсор переметился на один узел вправо
    public void right();
    
    // предусловие: связанный список не пустой
    // постусловие: вставлен следом за текущим узлом новый узел с заданным значением
    public void put_right(T value);
    
    // предусловие: связанный список не пустой
    // постусловие: вставлен перед текущим узлом новый узел с заданным значением
    public void put_left(T value);
    
    // предусловие: связанный список не пустой
    // постусловие: текущий узел удален. курсор сместился к правому соседу, если он есть, в противном случае курсор сместился к левому соседу, если он есть
    public void remove();
    
    // постусловие: связанный список пустой
    public void clear();
    
    // постусловие: добавлен новый узел в хвост списка
    public void add_tail(T value);
    
    // предусловие: связанный список не пустой
    // постусловие: значение текущего узла заменено заданным значением
    public void replace(T value);
    
    // предусловие: связанный список не пустой
    // постусловие: курсор установлен на следующий узел с искомым значением (по отношению к текущему узлу)
    public void find(T value);
    
    // предусловие: связанный список не пустой
    // постусловие: в списке удалены все узлы с заданным значением
    public void remove_all(T value);
    
    // запросы:
    // предусловие: связанный список не пустой
    public T get();
    
    public int size();
    
    public bool is_head();
    
    public bool is_tail();
    
    public bool is_value();
    
    // дополнительные запросы:
    public int get_head_status(); // возвращает значение HEAD_*
    public int get_tail_status(); // возвращает значение TAIL_*
    public int get_right_status(); // возвращает значение RIGHT_*
    public int get_put_right_status(); // возвращает значение PUT_RIGHT_*
    public int get_put_left_status(); // возвращает значение PUT_LEFT_*
    public int get_remove_status(); // возвращает значение REMOVE_*
    public int get_replace_status(); // возвращает значение REPLACE_*
    public int get_find_status(); // возвращает значение FIND_*
    public int get_remove_all_status(); // возвращает значение REMOVE_ALL_*
    public int get_get_status(); // возвращает значение GET_* 
              
              
2.2. Почему операция tail не сводима к другим операциям (если исходить из эффективной реализации)?
--- Операция получения последнего элемента(сложность) O(1), операция через другие реализации - O(n)

2.3. Операция поиска всех узлов с заданным значением, выдающая список таких узлов, уже не нужна. Почему?
---- можно реализовать через find
 */


using System;
using System.Collections.Generic;

namespace TestSpace
{
    public class LinkedList<T>
    {
    }
}